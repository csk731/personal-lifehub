'use client';

import React, { useState, useEffect, useRef } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { 
  Plus, 
  Search, 
  Filter, 
  MoreVertical, 
  Edit3, 
  Trash2, 
  Star, 
  StarOff,
  Calendar,
  Clock,
  Tag,
  Folder,
  Archive,
  Pin,
  PinOff,
  Eye,
  EyeOff,
  Share2,
  Copy,
  Download,
  Settings,
  Grid,
  List,
  SortAsc,
  SortDesc,
  X,
  Check,
  Save,
  RotateCcw,
  Palette,
  Type,
  Bold,
  Italic,
  List as ListIcon,
  AlignLeft,
  AlignCenter,
  AlignRight,
  Link as LinkIcon,
  Image,
  Paperclip,
  Smile,
  Hash,
  Bookmark,
  BookmarkPlus,
  ArrowLeft,
  FileText,
  TrendingUp,
  Target,
  Zap,
  CheckCircle,
  AlertCircle,
  Circle,
  MinusCircle,
  ChevronRight,
  FolderOpen,
  FolderPlus,
  Trash,
  Settings as SettingsIcon,
  Edit
} from 'lucide-react';
import { TopBar } from '@/components/dashboard/TopBar';
import { getAuthHeaders } from '@/lib/utils';
import Link from 'next/link';

interface Note {
  id: string;
  title: string;
  content: string;
  tags: string[];
  folderId?: string;
  folderName?: string;
  folderColor?: string;
  folderEmoji?: string;
  isPinned: boolean;
  isStarred: boolean;
  isArchived: boolean;
  color: string;
  created_at: string;
  updated_at: string;
  wordCount: number;
  characterCount: number;
}

interface Folder {
  id: string;
  name: string;
  color: string;
  icon: string;
  emoji: string;
  is_default: boolean;
  sort_order: number;
  created_at: string;
  updated_at: string;
}

interface NoteCategory {
  id: string;
  name: string;
  color: string;
  icon: string;
}

const noteColors = [
  { name: 'default', bg: 'bg-white', border: 'border-gray-200', text: 'text-gray-800' },
  { name: 'blue', bg: 'bg-blue-50', border: 'border-blue-200', text: 'text-blue-800' },
  { name: 'green', bg: 'bg-green-50', border: 'border-green-200', text: 'text-green-800' },
  { name: 'yellow', bg: 'bg-yellow-50', border: 'border-yellow-200', text: 'text-yellow-800' },
  { name: 'pink', bg: 'bg-pink-50', border: 'border-pink-200', text: 'text-pink-800' },
  { name: 'purple', bg: 'bg-purple-50', border: 'border-purple-200', text: 'text-purple-800' },
];

const categoryIcons = {
  'personal': { emoji: 'üìù', color: 'text-blue-600', bg: 'bg-blue-100' },
  'work': { emoji: 'üíº', color: 'text-green-600', bg: 'bg-green-100' },
  'ideas': { emoji: 'üí°', color: 'text-yellow-600', bg: 'bg-yellow-100' },
  'todo': { emoji: '‚úÖ', color: 'text-pink-600', bg: 'bg-pink-100' },
  'study': { emoji: 'üìö', color: 'text-purple-600', bg: 'bg-purple-100' },
  'other': { emoji: 'üìã', color: 'text-gray-600', bg: 'bg-gray-100' }
};

const priorityColors = {
  low: { text: 'text-gray-500', bg: 'bg-gray-100', icon: MinusCircle, emoji: 'üü¢' },
  medium: { text: 'text-blue-600', bg: 'bg-blue-100', icon: Circle, emoji: 'üü°' },
  high: { text: 'text-orange-600', bg: 'bg-orange-100', icon: AlertCircle, emoji: 'üü†' },
  urgent: { text: 'text-red-600', bg: 'bg-red-100', icon: Zap, emoji: 'üî¥' }
}

export default function NotesDashboard() {
  const [notes, setNotes] = useState<Note[]>([]);
  const [folders, setFolders] = useState<Folder[]>([]);
  const [filteredNotes, setFilteredNotes] = useState<Note[]>([]);
  const [selectedNote, setSelectedNote] = useState<Note | null>(null);
  const [isEditing, setIsEditing] = useState(false);
  const [isCreating, setIsCreating] = useState(false);
  const [searchQuery, setSearchQuery] = useState('');
  const [selectedFolderId, setSelectedFolderId] = useState<string>('all');
  const [viewMode, setViewMode] = useState<'grid' | 'list'>('list');
  const [sortBy, setSortBy] = useState<'date' | 'title' | 'updated'>('updated');
  const [sortOrder, setSortOrder] = useState<'asc' | 'desc'>('desc');
  const [showArchived, setShowArchived] = useState(false);
  const [showStarred, setShowStarred] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [isSaving, setIsSaving] = useState(false);
  const [showSuccess, setShowSuccess] = useState(false);
  const [successMessage, setSuccessMessage] = useState('');
  const [deletingNotes, setDeletingNotes] = useState<Set<string>>(new Set());
  const [openMenuId, setOpenMenuId] = useState<string | null>(null);
  const [tagsInput, setTagsInput] = useState('');
  const [sidebarCollapsed, setSidebarCollapsed] = useState(false);
  const [showCreateFolder, setShowCreateFolder] = useState(false);
  const [newFolderName, setNewFolderName] = useState('');
  const [isCreatingFolder, setIsCreatingFolder] = useState(false);
  const [editingFolder, setEditingFolder] = useState<string | null>(null);
  const [deletingFolder, setDeletingFolder] = useState<string | null>(null);
  const [showFolderColorPicker, setShowFolderColorPicker] = useState<string | null>(null);
  const [folderStats, setFolderStats] = useState<Record<string, any>>({});
  const [draggedFolderId, setDraggedFolderId] = useState<string | null>(null);
  const [dragOverFolderId, setDragOverFolderId] = useState<string | null>(null);
  const [isReorderingFolders, setIsReorderingFolders] = useState(false);
  // Add tag management state
  const [selectedTags, setSelectedTags] = useState<Set<string>>(new Set());
  const [tagSuggestions, setTagSuggestions] = useState<string[]>([]);
  const [showTagSuggestions, setShowTagSuggestions] = useState(false);
  // Add color picker state
  const [showNoteColorPicker, setShowNoteColorPicker] = useState(false);
  // Add folder selector state
  const [showFolderSelector, setShowFolderSelector] = useState(false);
  // Add confirmation dialog state
  const [confirmationDialog, setConfirmationDialog] = useState<{
    isOpen: boolean;
    title: string;
    message: string;
    confirmText: string;
    cancelText: string;
    onConfirm: () => void;
    isDestructive?: boolean;
  } | null>(null);
  
  const editorRef = useRef<HTMLTextAreaElement>(null);
  const searchRef = useRef<HTMLInputElement>(null);
  const tagsInputRef = useRef<HTMLInputElement>(null);

  // New note template
  const newNoteTemplate: Omit<Note, 'id' | 'created_at' | 'updated_at' | 'wordCount' | 'characterCount'> = {
    title: '',
    content: '',
    tags: [],
    folderId: undefined,
    folderName: undefined,
    folderColor: undefined,
    folderEmoji: undefined,
    isPinned: false,
    isStarred: false,
    isArchived: false,
    color: 'default',
  };

  const colorOptions = [
    { name: 'blue', bg: 'bg-blue-50', border: 'border-blue-200', text: 'text-blue-900' },
    { name: 'green', bg: 'bg-green-50', border: 'border-green-200', text: 'text-green-900' },
    { name: 'purple', bg: 'bg-purple-50', border: 'border-purple-200', text: 'text-purple-900' },
    { name: 'red', bg: 'bg-red-50', border: 'border-red-200', text: 'text-red-900' },
    { name: 'yellow', bg: 'bg-yellow-50', border: 'border-yellow-200', text: 'text-yellow-900' },
    { name: 'pink', bg: 'bg-pink-50', border: 'border-pink-200', text: 'text-pink-900' },
    { name: 'indigo', bg: 'bg-indigo-50', border: 'border-indigo-200', text: 'text-indigo-900' },
    { name: 'gray', bg: 'bg-gray-50', border: 'border-gray-200', text: 'text-gray-900' },
    { name: 'orange', bg: 'bg-orange-50', border: 'border-orange-200', text: 'text-orange-900' },
    { name: 'teal', bg: 'bg-teal-50', border: 'border-teal-200', text: 'text-teal-900' },
    { name: 'cyan', bg: 'bg-cyan-50', border: 'border-cyan-200', text: 'text-cyan-900' },
    { name: 'lime', bg: 'bg-lime-50', border: 'border-lime-200', text: 'text-lime-900' }
  ];

  // Add note color options (same as folder colors)
  const noteColorOptions = [
    { name: 'default', bg: 'bg-white', border: 'border-gray-200', text: 'text-gray-900' },
    { name: 'blue', bg: 'bg-blue-50', border: 'border-blue-200', text: 'text-blue-900' },
    { name: 'green', bg: 'bg-green-50', border: 'border-green-200', text: 'text-green-900' },
    { name: 'purple', bg: 'bg-purple-50', border: 'border-purple-200', text: 'text-purple-900' },
    { name: 'red', bg: 'bg-red-50', border: 'border-red-200', text: 'text-red-900' },
    { name: 'yellow', bg: 'bg-yellow-50', border: 'border-yellow-200', text: 'text-yellow-900' },
    { name: 'pink', bg: 'bg-pink-50', border: 'border-pink-200', text: 'text-pink-900' },
    { name: 'indigo', bg: 'bg-indigo-50', border: 'border-indigo-200', text: 'text-indigo-900' },
    { name: 'gray', bg: 'bg-gray-50', border: 'border-gray-200', text: 'text-gray-900' },
    { name: 'orange', bg: 'bg-orange-50', border: 'border-orange-200', text: 'text-orange-900' },
    { name: 'teal', bg: 'bg-teal-50', border: 'border-teal-200', text: 'text-teal-900' },
    { name: 'cyan', bg: 'bg-cyan-50', border: 'border-cyan-200', text: 'text-cyan-900' },
  ];

  useEffect(() => {
    fetchNotes();
    fetchFolders();
  }, []);

  useEffect(() => {
    filterAndSortNotes();
  }, [notes, searchQuery, selectedFolderId, selectedTags, showArchived, showStarred, sortBy, sortOrder]);

  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      // Don't handle global shortcuts when editing in the editor
      if (document.activeElement?.tagName === 'TEXTAREA' ||
          document.activeElement?.tagName === 'INPUT' ||
          document.activeElement?.tagName === 'SELECT') {
        return;
      }

      if (showSuccess) return;
      
      // Save on Ctrl+S or Cmd+S
      if ((e.ctrlKey || e.metaKey) && e.key === 's') {
        e.preventDefault();
        if (isEditing && (selectedNote || isCreating)) {
          handleSaveNote();
        }
      }
      
      // Escape to close editor
      if (e.key === 'Escape') {
        if (selectedNote || isCreating) {
          setSelectedNote(null);
          setIsCreating(false);
          setIsEditing(false);
        }
      }

      // Ctrl+N to create new note
      if ((e.ctrlKey || e.metaKey) && e.key === 'n') {
        e.preventDefault();
        handleCreateNote();
      }
    };

    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, [isEditing, selectedNote, isCreating, showSuccess]);

  // Focus editor when note is selected
  useEffect(() => {
    if (selectedNote && editorRef.current) {
      // Handle new notes - focus the textarea
      if (selectedNote.id === 'new') {
        editorRef.current.focus();
        return;
      }
      
      // Handle existing notes - focus the textarea
      editorRef.current.focus();
    }
  }, [selectedNote?.id]);

  useEffect(() => {
    if (folders.length > 0) {
      fetchFolderStats();
    }
  }, [folders]);

  const fetchFolderStats = async () => {
    try {
      const headers = await getAuthHeaders();
      const response = await fetch('/api/folders/stats', { headers });
      if (!response.ok) throw new Error('Failed to fetch folder stats');
      const data = await response.json();
      if (data.error) throw new Error(data.error);
      // Map stats by folderId for quick lookup
      const statsMap: Record<string, any> = {};
      (data.stats || []).forEach((stat: any) => {
        statsMap[stat.folder_id] = stat;
      });
      setFolderStats(statsMap);
    } catch (err) {
      // Optionally set error state
      console.error('Error fetching folder stats:', err);
    }
  };

  const fetchNotes = async () => {
    try {
      setIsLoading(true);
      setError(null);
      
      const headers = await getAuthHeaders();
      const response = await fetch('/api/notes', { headers });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const data = await response.json();
      
      if (data.error) {
        throw new Error(data.error);
      }
      
      // Ensure all notes have proper default values
      const processedNotes = (data.notes || []).map((note: any) => ({
        id: note.id,
        title: note.title || '',
        content: note.content || '',
        tags: Array.isArray(note.tags) ? note.tags : [],
        folderId: note.folderId || note.folder_id || undefined,
        folderName: note.folderName || note.folder_name || undefined,
        folderColor: note.folderColor || note.folder_color || undefined,
        folderEmoji: note.folderEmoji || note.folder_emoji || undefined,
        isPinned: Boolean(note.isPinned),
        isStarred: Boolean(note.isStarred),
        isArchived: Boolean(note.isArchived),
        color: note.color || 'default',
        created_at: note.created_at,
        updated_at: note.updated_at,
        wordCount: note.wordCount || 0,
        characterCount: note.characterCount || 0,
      }));
      
      setNotes(processedNotes);
    } catch (err) {
      console.error('Error fetching notes:', err);
      setError(err instanceof Error ? err.message : 'Failed to fetch notes');
    } finally {
      setIsLoading(false);
    }
  };

  const fetchFolders = async () => {
    try {
      const headers = await getAuthHeaders();
      const response = await fetch('/api/folders', { headers });
      
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      
      const data = await response.json();
      
      if (data.error) {
        throw new Error(data.error);
      }
      
      setFolders(data.folders || []);
    } catch (err) {
      console.error('Error fetching folders:', err);
      setError(err instanceof Error ? err.message : 'Failed to fetch folders');
    }
  };

  const filterAndSortNotes = () => {
    let filtered = [...notes];

    // Filter by search query
    if (searchQuery.trim()) {
      const query = searchQuery.toLowerCase().trim();
      filtered = filtered.filter(note => 
        note.title.toLowerCase().includes(query) ||
        note.content.toLowerCase().includes(query) ||
        note.tags.some(tag => tag.toLowerCase().includes(query))
      );
    }

    // Filter by folder
    if (selectedFolderId !== 'all') {
      filtered = filtered.filter(note => note.folderId === selectedFolderId);
    }

    // Filter by tags
    filtered = filterNotesByTags(filtered);

    // Filter by archived status
    if (!showArchived) {
      filtered = filtered.filter(note => !note.isArchived);
    }

    // Filter by starred status
    if (showStarred) {
      filtered = filtered.filter(note => note.isStarred);
    }

    // Sort notes
    filtered.sort((a, b) => {
      let comparison = 0;
      
      switch (sortBy) {
        case 'title':
          comparison = (a.title || '').localeCompare(b.title || '');
          break;
        case 'date':
          comparison = new Date(a.created_at).getTime() - new Date(b.created_at).getTime();
          break;
        case 'updated':
        default:
          comparison = new Date(a.updated_at).getTime() - new Date(b.updated_at).getTime();
          break;
      }
      
      return sortOrder === 'asc' ? comparison : -comparison;
    });

    // Prioritize pinned notes
    filtered.sort((a, b) => {
      if (a.isPinned && !b.isPinned) return -1;
      if (!a.isPinned && b.isPinned) return 1;
      return 0;
    });

    setFilteredNotes(filtered);
  };

  const createNote = async (noteData: Partial<Note>) => {
    try {
      const headers = await getAuthHeaders();
      const response = await fetch('/api/notes', {
        method: 'POST',
        headers: {
          ...headers,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(noteData),
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const newNote = await response.json();
      
      if (newNote.error) {
        throw new Error(newNote.error);
      }

      setNotes(prev => [newNote, ...prev]);
      return newNote;
    } catch (err) {
      console.error('Error creating note:', err);
      throw err;
    }
  };

  const updateNote = async (noteId: string, updates: Partial<Note>) => {
    try {
      const headers = await getAuthHeaders();
      const response = await fetch(`/api/notes/${noteId}`, {
        method: 'PUT',
        headers: {
          ...headers,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(updates),
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const updatedNote = await response.json();
      
      if (updatedNote.error) {
        throw new Error(updatedNote.error);
      }

      setNotes(prev => prev.map(note => 
        note.id === noteId ? updatedNote : note
      ));
      
      return updatedNote;
    } catch (err) {
      console.error('Error updating note:', err);
      throw err;
    }
  };

  const deleteNote = async (noteId: string) => {
    try {
      setDeletingNotes(prev => new Set(prev).add(noteId));
      
      const headers = await getAuthHeaders();
      const response = await fetch(`/api/notes/${noteId}`, {
        method: 'DELETE',
        headers,
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const result = await response.json();
      
      if (result.error) {
        throw new Error(result.error);
      }

      setNotes(prev => prev.filter(note => note.id !== noteId));
      
      if (selectedNote?.id === noteId) {
        setSelectedNote(null);
        setIsEditing(false);
        setIsCreating(false);
      }
    } catch (err) {
      console.error('Error deleting note:', err);
      throw err;
    } finally {
      setDeletingNotes(prev => {
        const newSet = new Set(prev);
        newSet.delete(noteId);
        return newSet;
      });
    }
  };

  const handleCreateNote = () => {
    const newNote: Note = {
      ...newNoteTemplate,
      id: 'new',
      folderId: undefined,
      folderName: undefined,
      folderColor: undefined,
      folderEmoji: undefined,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
      wordCount: 0,
      characterCount: 0
    };
    
    setSelectedNote(newNote);
    setIsCreating(true);
    setIsEditing(true);
    setTagsInput('');
    
    // Focus the editor after a short delay to ensure state is updated
    setTimeout(() => {
      if (editorRef.current) {
        editorRef.current.focus();
      }
    }, 50);
  };

  const handleCreateNoteInFolder = (folderId: string) => {
    const selectedFolder = folders.find(f => f.id === folderId);
    
    const newNote: Note = {
      ...newNoteTemplate,
      id: 'new',
      folderId: selectedFolder?.id,
      folderName: selectedFolder?.name,
      folderColor: selectedFolder?.color,
      folderEmoji: selectedFolder?.emoji,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
      wordCount: 0,
      characterCount: 0
    };
    
    setSelectedNote(newNote);
    setIsCreating(true);
    setIsEditing(true);
    setTagsInput('');
    
    // Focus the editor after a short delay to ensure state is updated
    setTimeout(() => {
      if (editorRef.current) {
        editorRef.current.focus();
      }
    }, 50);
  };

  const handleSaveNote = async () => {
    if (!selectedNote && !isCreating) return;

    try {
      setIsSaving(true);
      setError(null);

      const currentNote = selectedNote || { ...newNoteTemplate, id: 'new', created_at: new Date().toISOString(), updated_at: new Date().toISOString(), wordCount: 0, characterCount: 0 };
      
      // Calculate word and character counts
      const wordCount = currentNote.content ? 
        currentNote.content.trim().split(/\s+/).filter(word => word.length > 0).length : 0;
      const characterCount = currentNote.content ? currentNote.content.length : 0;

      const noteData = {
        ...currentNote,
        wordCount,
        characterCount,
        // Ensure folderId is properly set for the API
        folderId: currentNote.folderId || undefined,
      };

      let savedNote;

      if (isCreating) {
        savedNote = await createNote(noteData);
        setIsCreating(false);
      } else {
        savedNote = await updateNote(currentNote.id, noteData);
      }

      setSelectedNote(savedNote);
      setIsEditing(false);
      setShowSuccess(true);
      setSuccessMessage('Note saved successfully!');
      
      setTimeout(() => setShowSuccess(false), 2000);
    } catch (err) {
      console.error('Error saving note:', err);
      setError(err instanceof Error ? err.message : 'Failed to save note');
    } finally {
      setIsSaving(false);
    }
  };

  const handleDeleteNote = async (noteId: string) => {
    showConfirmation({
      title: 'Delete Note',
      message: 'Are you sure you want to delete this note? This action cannot be undone.',
      confirmText: 'Delete',
      cancelText: 'Cancel',
      onConfirm: async () => {
        try {
          await deleteNote(noteId);
        } catch (err) {
          console.error('Error deleting note:', err);
          setError(err instanceof Error ? err.message : 'Failed to delete note');
        }
      },
      isDestructive: true,
    });
  };

  const togglePin = async (noteId: string) => {
      const note = notes.find(n => n.id === noteId);
      if (!note) return;

    try {
      await updateNote(noteId, { isPinned: !note.isPinned });
    } catch (err) {
      console.error('Error toggling pin:', err);
      setError(err instanceof Error ? err.message : 'Failed to toggle pin');
    }
  };

  const toggleStar = async (noteId: string) => {
      const note = notes.find(n => n.id === noteId);
      if (!note) return;

    try {
      await updateNote(noteId, { isStarred: !note.isStarred });
    } catch (err) {
      console.error('Error toggling star:', err);
      setError(err instanceof Error ? err.message : 'Failed to toggle star');
    }
  };

  const toggleArchive = async (noteId: string) => {
      const note = notes.find(n => n.id === noteId);
      if (!note) return;

    try {
      await updateNote(noteId, { isArchived: !note.isArchived });
    } catch (err) {
      console.error('Error toggling archive:', err);
      setError(err instanceof Error ? err.message : 'Failed to toggle archive');
    }
  };

  const formatDate = (dateString: string) => {
    return new Date(dateString).toLocaleDateString('en-US', { 
      month: 'short', 
      day: 'numeric',
      year: new Date(dateString).getFullYear() !== new Date().getFullYear() ? 'numeric' : undefined
    });
  };

  const formatTime = (dateString: string) => {
    return new Date(dateString).toLocaleTimeString('en-US', { 
      hour: 'numeric', 
      minute: '2-digit',
      hour12: true 
    });
  };

  const getCategoryInfo = (categoryId: string) => {
    return categoryIcons[categoryId as keyof typeof categoryIcons] || categoryIcons.other;
  };

  const getColorInfo = (colorName: string) => {
    const color = colorOptions.find(c => c.name === colorName) || colorOptions[0];
    return color;
  };

  const getNoteStats = () => {
    return {
      total: notes.length,
      pinned: notes.filter(note => note.isPinned).length,
      starred: notes.filter(note => note.isStarred).length,
      archived: notes.filter(note => note.isArchived).length,
    };
  };

  const handleCreateFolder = async () => {
    if (!newFolderName.trim()) {
      setError('Folder name cannot be empty');
      return;
    }

    // Check for duplicate folder names
    if (folders.some(f => f.name.toLowerCase() === newFolderName.trim().toLowerCase())) {
      setError('A folder with this name already exists');
      return;
    }

    try {
      setIsCreatingFolder(true);
      setError(null);

      const headers = await getAuthHeaders();
      const response = await fetch('/api/folders', {
        method: 'POST',
        headers: {
          ...headers,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          name: newFolderName.trim(),
          color: 'blue',
          emoji: 'üìÅ'
        }),
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const newFolder = await response.json();
      
      if (newFolder.error) {
        throw new Error(newFolder.error);
      }

      setFolders(prev => [...prev, newFolder]);
      setNewFolderName('');
      setShowCreateFolder(false);
      setShowSuccess(true);
      setSuccessMessage(`Folder "${newFolder.name}" created successfully!`);
      
      setTimeout(() => setShowSuccess(false), 2000);
    } catch (err) {
      console.error('Error creating folder:', err);
      setError(err instanceof Error ? err.message : 'Failed to create folder');
    } finally {
      setIsCreatingFolder(false);
    }
  };

  const handleEditFolder = async (folderId: string, newName: string, newColor: string, newEmoji: string) => {
    if (!newName.trim()) {
      setError('Folder name cannot be empty');
      return;
    }

    const folder = folders.find(f => f.id === folderId);
    if (!folder) return;

    // Check for duplicate folder names (excluding current folder)
    if (folders.some(f => f.id !== folderId && f.name.toLowerCase() === newName.trim().toLowerCase())) {
      setError('A folder with this name already exists');
      return;
    }

    try {
      setError(null);

      const headers = await getAuthHeaders();
      const response = await fetch(`/api/folders/${folderId}`, {
        method: 'PUT',
        headers: {
          ...headers,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          name: newName.trim(),
          color: newColor,
          emoji: newEmoji
        }),
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const updatedFolder = await response.json();
      
      if (updatedFolder.error) {
        throw new Error(updatedFolder.error);
      }

      // Update folders list
      setFolders(prev => prev.map(f => f.id === folderId ? updatedFolder : f));
      
      // Update notes that belong to this folder
      setNotes(prev => prev.map(note => 
        note.folderId === folderId 
          ? { ...note, folderName: newName.trim(), folderColor: newColor, folderEmoji: newEmoji }
          : note
      ));

      setEditingFolder(null);
      setShowSuccess(true);
      setSuccessMessage(`Folder "${newName.trim()}" updated successfully!`);
      
      setTimeout(() => setShowSuccess(false), 2000);
    } catch (err) {
      console.error('Error updating folder:', err);
      setError(err instanceof Error ? err.message : 'Failed to update folder');
    }
  };

  const handleDeleteFolder = async (folderId: string) => {
    const folder = folders.find(f => f.id === folderId);
    const noteCount = notes.filter(note => note.folderId === folderId).length;
    
    const message = noteCount > 0 
      ? `Are you sure you want to delete the folder "${folder?.name}"? This will unassign ${noteCount} notes from this folder (notes will not be deleted). This action cannot be undone.`
      : `Are you sure you want to delete the folder "${folder?.name}"? This action cannot be undone.`;

    showConfirmation({
      title: 'Delete Folder',
      message,
      confirmText: 'Delete',
      cancelText: 'Cancel',
      onConfirm: async () => {
        try {
          setDeletingFolder(folderId);
          setError(null);

          const headers = await getAuthHeaders();
          const response = await fetch(`/api/folders/${folderId}`, {
            method: 'DELETE',
            headers,
          });

          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }

          const result = await response.json();
          
          if (result.error) {
            throw new Error(result.error);
          }

          // Remove folder from list
          setFolders(prev => prev.filter(f => f.id !== folderId));
          
          // Unassign notes from this folder (set folderId to null)
          setNotes(prev => prev.map(note => 
            note.folderId === folderId 
              ? { ...note, folderId: undefined, folderName: undefined, folderColor: undefined, folderEmoji: undefined }
              : note
          ));
          
          // If we're currently viewing this folder, switch to "All Notes"
          if (selectedFolderId === folderId) {
            setSelectedFolderId('all');
          }

          setDeletingFolder(null);
          setShowSuccess(true);
          setSuccessMessage(`Folder "${folder?.name}" deleted successfully! ${noteCount > 0 ? `${noteCount} notes have been unassigned.` : ''}`);
          
          setTimeout(() => setShowSuccess(false), 3000);
        } catch (err) {
          console.error('Error deleting folder:', err);
          setError(err instanceof Error ? err.message : 'Failed to delete folder');
        } finally {
          setDeletingFolder(null);
        }
      },
      isDestructive: true,
    });
  };

  const handleUpdateFolderColor = async (folderId: string, newColor: string) => {
    try {
      const folder = folders.find(f => f.id === folderId);
      if (!folder) return;

      await handleEditFolder(folderId, folder.name, newColor, folder.emoji);
      setShowFolderColorPicker(null);
    } catch (err) {
      console.error('Error updating folder color:', err);
      setError(err instanceof Error ? err.message : 'Failed to update folder color');
    }
  };

  const handleFolderClick = (folderId: string) => {
    setSelectedFolderId(folderId);
    // Clear any selected note when switching folders
    setSelectedNote(null);
          setIsEditing(false);
          setIsCreating(false);
  };

  const renderSidebar = () => {
    const stats = getNoteStats();

    return (
      <div className={`bg-gray-50 border-r border-gray-200 transition-all duration-300 ${
        sidebarCollapsed ? 'w-16' : 'w-80'
      }`}>
        {/* Sidebar Header */}
        <div className="p-4 border-b border-gray-200">
          <div className="flex items-center justify-between">
            {!sidebarCollapsed && (
              <div className="flex items-center space-x-2">
                <h1 className="text-lg font-semibold text-gray-900">Notes</h1>
              </div>
            )}
            <button
              onClick={() => setSidebarCollapsed(!sidebarCollapsed)}
              className="p-1 rounded hover:bg-gray-200 transition-colors"
            >
              <ChevronRight className={`w-4 h-4 text-gray-600 transition-transform ${
                sidebarCollapsed ? 'rotate-180' : ''
              }`} />
            </button>
          </div>
        </div>

        {/* Search */}
        {!sidebarCollapsed && (
          <div className="p-4 border-b border-gray-200">
          <div className="relative">
              <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 w-4 h-4" />
              <input
                ref={searchRef}
                type="text"
                placeholder="Search notes..."
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
                className="w-full pl-9 pr-3 py-2 text-sm border border-gray-200 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
              />
            </div>
          </div>
        )}

        {/* Folders */}
        {!sidebarCollapsed && (
          <div className="p-4 border-b border-gray-200">
            <div className="space-y-1">
              <div className="flex items-center justify-between">
                <span className="text-xs font-medium text-gray-500 uppercase tracking-wide">Folders</span>
            <button
                  onClick={() => setShowCreateFolder(true)}
                  className="p-1 rounded hover:bg-gray-200 transition-colors"
                >
                  <FolderPlus className="w-3 h-3 text-gray-400" />
            </button>
              </div>
              <div className="space-y-1 mt-2">
                <button
                  onClick={() => setSelectedFolderId('all')}
                  className={`w-full flex items-center space-x-2 px-2 py-1.5 rounded text-sm transition-colors ${
                    selectedFolderId === 'all' ? 'bg-blue-100 text-blue-700' : 'hover:bg-gray-100 text-gray-700'
                  }`}
                >
                  <Folder className="w-4 h-4" />
                  <span>All Notes</span>
                  <span className="ml-auto text-xs text-gray-400">{stats.total}</span>
                </button>
                {folders
                  .sort((a, b) => a.sort_order - b.sort_order)
                  .map((folder) => (
                    <div 
                      key={folder.id} 
                      className={`group relative ${
                        draggedFolderId === folder.id ? 'opacity-50' : ''
                      } ${
                        dragOverFolderId === folder.id ? 'bg-blue-50 border-l-2 border-blue-500' : ''
                      }`}
                      draggable
                      onDragStart={(e) => handleDragStart(e, folder.id)}
                      onDragOver={(e) => handleDragOver(e, folder.id)}
                      onDragLeave={handleDragLeave}
                      onDrop={(e) => handleDrop(e, folder.id)}
                      onDragEnd={handleDragEnd}
                    >
                      <button
                        onClick={() => setSelectedFolderId(folder.id)}
                        className={`w-full flex items-center space-x-2 px-2 py-1.5 rounded text-sm transition-colors ${
                          selectedFolderId === folder.id ? 'bg-blue-100 text-blue-700' : 'hover:bg-gray-100 text-gray-700'
                        }`}
                      >
                        <span className="text-base cursor-move">‚ãÆ‚ãÆ</span>
                        <span className="text-base">{folder.emoji}</span>
                        <span className="flex-1 text-left truncate">{folder.name}</span>
                        <span className="text-xs text-gray-400">
                          {folderStats[folder.id]?.note_count ?? 0}
                        </span>
                      </button>
                      
                      {/* Folder stats */}
                      {folderStats[folder.id] && (
                        <div className="ml-8 pl-2 text-xs text-gray-500 flex flex-col">
                          <span>üìù {folderStats[folder.id].note_count} notes</span>
                          <span>üî§ {folderStats[folder.id].total_words} words</span>
                          <span>üî° {folderStats[folder.id].total_characters} chars</span>
                          <span>‚è∞ {folderStats[folder.id].last_updated ? new Date(folderStats[folder.id].last_updated).toLocaleDateString() : '-'}</span>
                        </div>
                      )}
                      
                      {/* Folder Actions Menu */}
                      <div className="absolute right-1 top-1/2 transform -translate-y-1/2 opacity-0 group-hover:opacity-100 transition-opacity">
                        <div className="relative">
                          <button
                            onClick={(e) => {
                              e.stopPropagation();
                              setEditingFolder(editingFolder === folder.id ? null : folder.id);
                            }}
                            className="p-1 rounded hover:bg-gray-200 transition-colors"
                          >
                            <Edit className="w-3 h-3 text-gray-400" />
                          </button>
                          
                          {editingFolder === folder.id && (
                            <div className="absolute right-0 top-6 bg-white border border-gray-200 rounded-lg shadow-lg z-10 py-1 w-56">
                              <div className="p-3">
                                <div className="mb-3">
                                  <label className="block text-xs font-medium text-gray-700 mb-1">Folder Name</label>
                                  <input
                                    type="text"
                                    defaultValue={folder.name}
                                    className="w-full text-sm border border-gray-300 rounded px-2 py-1 focus:outline-none focus:ring-2 focus:ring-blue-500"
                                    placeholder="Folder name"
                                    onKeyDown={(e) => {
                                      if (e.key === 'Enter') {
                                        const input = e.target as HTMLInputElement;
                                        handleEditFolder(folder.id, input.value, folder.color, folder.emoji);
                                      }
                                    }}
                                  />
                                </div>
                                
                                <div className="mb-3">
                                  <label className="block text-xs font-medium text-gray-700 mb-2">Color Theme</label>
                                  <div className="grid grid-cols-4 gap-2">
                                    {colorOptions.map((color) => (
                                      <button
                                        key={color.name}
                                        onClick={() => handleUpdateFolderColor(folder.id, color.name)}
                                        className={`w-8 h-8 rounded-lg border-2 transition-all ${
                                          folder.color === color.name 
                                            ? 'border-gray-600 scale-110' 
                                            : 'border-gray-200 hover:border-gray-400'
                                        } ${color.bg}`}
                                        title={color.name}
                                      />
                                    ))}
                                  </div>
                                </div>
                                
                                <div className="flex space-x-2">
                                  <button
                                    onClick={() => {
                                      const input = document.querySelector(`input[defaultValue="${folder.name}"]`) as HTMLInputElement;
                                      if (input) {
                                        handleEditFolder(folder.id, input.value, folder.color, folder.emoji);
                                      }
                                    }}
                                    className="flex-1 px-3 py-1.5 text-xs bg-blue-500 text-white rounded hover:bg-blue-600 transition-colors"
                                  >
                                    Save
                                  </button>
                                  <button
                                    onClick={() => setEditingFolder(null)}
                                    className="flex-1 px-3 py-1.5 text-xs bg-gray-300 text-gray-700 rounded hover:bg-gray-400 transition-colors"
                                  >
                                    Cancel
                                  </button>
                                </div>
                              </div>
                            </div>
                          )}
                        </div>
                      </div>
                      
                      {/* Delete Button */}
                      <div className="absolute right-6 top-1/2 transform -translate-y-1/2 opacity-0 group-hover:opacity-100 transition-opacity">
                        <button
                          onClick={(e) => {
                            e.stopPropagation();
                            handleDeleteFolder(folder.id);
                          }}
                          disabled={deletingFolder === folder.id}
                          className="p-1 rounded hover:bg-red-100 hover:text-red-600 transition-colors disabled:opacity-50"
                        >
                          {deletingFolder === folder.id ? (
                            <div className="animate-spin rounded-full h-3 w-3 border-b border-red-500"></div>
                          ) : (
                            <Trash2 className="w-3 h-3 text-gray-400" />
                          )}
                        </button>
                      </div>
                    </div>
                  ))}
              </div>
            </div>
          </div>
        )}

        {/* Quick Actions */}
        {!sidebarCollapsed && (
          <div className="p-4">
            <div className="space-y-1">
              <span className="text-xs font-medium text-gray-500 uppercase tracking-wide">Quick Actions</span>
              <div className="space-y-1 mt-2">
                <button
                  onClick={handleCreateNote}
                  className="w-full flex items-center space-x-2 px-2 py-1.5 rounded text-sm hover:bg-gray-100 text-gray-700 transition-colors"
                >
                  <Plus className="w-4 h-4" />
                  <span>New Note</span>
                </button>
                <button
                  onClick={() => setShowArchived(!showArchived)}
                  className={`w-full flex items-center space-x-2 px-2 py-1.5 rounded text-sm transition-colors ${
                    showArchived ? 'bg-blue-100 text-blue-700' : 'hover:bg-gray-100 text-gray-700'
                  }`}
                >
                  <Archive className="w-4 h-4" />
                  <span>Archived</span>
                  <span className="ml-auto text-xs text-gray-400">{stats.archived}</span>
                </button>
                <button
                  onClick={() => setShowStarred(!showStarred)}
                  className={`w-full flex items-center space-x-2 px-2 py-1.5 rounded text-sm transition-colors ${
                    showStarred ? 'bg-blue-100 text-blue-700' : 'hover:bg-gray-100 text-gray-700'
                  }`}
                >
                  <Star className="w-4 h-4" />
                  <span>Starred</span>
                  <span className="ml-auto text-xs text-gray-400">{stats.starred}</span>
                </button>
              </div>
            </div>
          </div>
        )}

        {/* Tags Section */}
        {!sidebarCollapsed && (
          <div className="p-4 border-b border-gray-200">
            <div className="space-y-1">
              <div className="flex items-center justify-between">
                <span className="text-xs font-medium text-gray-500 uppercase tracking-wide">Tags</span>
                {selectedTags.size > 0 && (
                  <button
                    onClick={clearTagFilters}
                    className="text-xs text-blue-500 hover:text-blue-600"
                  >
                    Clear
                  </button>
                )}
              </div>
              <div className="space-y-1 mt-2">
                {getAllTags().map((tag) => {
                  const count = getTagCounts()[tag];
                  const isSelected = selectedTags.has(tag);
                  return (
                    <button
                      key={tag}
                      onClick={() => toggleTagFilter(tag)}
                      className={`w-full flex items-center justify-between px-2 py-1.5 rounded text-sm transition-colors ${
                        isSelected ? 'bg-blue-100 text-blue-700' : 'hover:bg-gray-100 text-gray-700'
                      }`}
                    >
                      <span className="flex items-center space-x-2">
                        <Hash className="w-3 h-3" />
                        <span className="truncate">#{tag}</span>
                      </span>
                      <span className="text-xs text-gray-400">{count}</span>
                    </button>
                  );
                })}
                {getAllTags().length === 0 && (
                  <p className="text-xs text-gray-500 italic">No tags yet</p>
                )}
              </div>
            </div>
          </div>
        )}
      </div>
    );
  };

  const renderNoteEditor = () => {
    if (!selectedNote && !isCreating) return null;

    const currentNote = selectedNote || { ...newNoteTemplate, id: 'new', created_at: new Date().toISOString(), updated_at: new Date().toISOString(), wordCount: 0, characterCount: 0 };

    return (
      <motion.div
        initial={{ opacity: 0, x: 20 }}
        animate={{ opacity: 1, x: 0 }}
        exit={{ opacity: 0, x: 20 }}
        className="flex-1 flex flex-col bg-white"
      >
        {/* Editor Header */}
        <div className="border-b border-gray-200 p-4">
          <div className="flex items-center justify-between">
            <div className="flex items-center space-x-3">
              <button
                onClick={() => {
                  setSelectedNote(null);
                  setIsCreating(false);
                  setIsEditing(false);
                }}
                className="p-1 rounded hover:bg-gray-100 transition-colors"
              >
                <ArrowLeft className="w-4 h-4 text-gray-600" />
              </button>
              <div className="flex items-center space-x-2">
                {currentNote.isPinned && <Pin className="w-4 h-4 text-gray-400" />}
                {currentNote.isStarred && <Star className="w-4 h-4 text-yellow-500" />}
              </div>
              <div className="flex items-center space-x-2">
                <span className="text-sm text-gray-500">
                  {isCreating ? 'New Note' : formatDate(currentNote.updated_at)}
                </span>
                {!isCreating && (
                  <span className="text-sm text-gray-400">
                    {formatTime(currentNote.updated_at)}
                  </span>
                )}
              </div>
            </div>
            
            <div className="flex items-center space-x-2">
              {/* Folder Selector */}
              <div className="relative">
                <button
                  onClick={() => setShowFolderSelector(!showFolderSelector)}
                  className="p-2 rounded hover:bg-gray-100 transition-colors flex items-center space-x-2"
                >
                  <Folder className="w-4 h-4 text-gray-600" />
                  <span className="text-sm text-gray-700">
                    {getCurrentFolderInfo()?.emoji || 'üìÅ'} {getCurrentFolderInfo()?.name || 'Unassigned'}
                  </span>
                  <ChevronRight className="w-3 h-3 text-gray-400" />
                </button>
                
                {showFolderSelector && (
                  <div className="absolute right-0 top-10 bg-white border border-gray-200 rounded-lg shadow-lg z-20 py-1 min-w-[200px]">
                    <div className="px-3 py-2 border-b border-gray-100">
                      <span className="text-xs font-medium text-gray-700">Move to Folder</span>
                    </div>
                    <button
                      onClick={() => moveNoteToFolder(undefined)}
                      className={`w-full flex items-center space-x-2 px-3 py-2 text-sm hover:bg-gray-50 text-left ${
                        !selectedNote?.folderId ? 'bg-blue-50 text-blue-700' : 'text-gray-700'
                      }`}
                    >
                      <span>üìÅ</span>
                      <span>Unassigned</span>
                    </button>
                    {folders.map((folder) => (
                      <button
                        key={folder.id}
                        onClick={() => moveNoteToFolder(folder.id)}
                        className={`w-full flex items-center space-x-2 px-3 py-2 text-sm hover:bg-gray-50 text-left ${
                          selectedNote?.folderId === folder.id ? 'bg-blue-50 text-blue-700' : 'text-gray-700'
                        }`}
                      >
                        <span>{folder.emoji}</span>
                        <span>{folder.name}</span>
                      </button>
                    ))}
                  </div>
                )}
              </div>
              
              {/* Color Picker */}
              <div className="relative">
                <button
                  onClick={() => setShowNoteColorPicker(!showNoteColorPicker)}
                  className="p-2 rounded hover:bg-gray-100 transition-colors flex items-center space-x-2"
                >
                  <Palette className="w-4 h-4 text-gray-600" />
                  <div className={`w-4 h-4 rounded-full border-2 border-gray-300 ${getCurrentNoteColorInfo().bg}`}></div>
                </button>
                
                {showNoteColorPicker && (
                  <div className="absolute right-0 top-10 bg-white border border-gray-200 rounded-lg shadow-lg z-20 p-3 min-w-[200px]">
                    <div className="mb-2">
                      <span className="text-xs font-medium text-gray-700">Note Color</span>
                    </div>
                    <div className="grid grid-cols-4 gap-2">
                      {noteColorOptions.map((color) => (
                        <button
                          key={color.name}
                          onClick={() => updateNoteColor(color.name)}
                          className={`w-8 h-8 rounded-lg border-2 transition-all ${
                            currentNote.color === color.name 
                              ? 'border-gray-600 scale-110' 
                              : 'border-gray-200 hover:border-gray-400'
                          } ${color.bg}`}
                          title={color.name}
                        />
                      ))}
                    </div>
                  </div>
                )}
              </div>
              
              {isSaving && (
                <div className="flex items-center space-x-2 text-sm text-gray-500">
                  <div className="animate-spin rounded-full h-3 w-3 border-b border-gray-500"></div>
                  <span>Saving...</span>
                </div>
              )}
              <button
                onClick={handleSaveNote}
                disabled={isSaving}
                className="px-3 py-1.5 text-sm bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors disabled:opacity-50"
              >
                Save
              </button>
            </div>
          </div>
        </div>

        {/* Editor Content */}
        <div className="flex-1 p-6 overflow-y-auto">
          <div className="max-w-4xl mx-auto">
            {/* Title Input */}
              <input
                type="text"
              placeholder="Title"
              value={currentNote.title}
              onChange={(e) => {
                if (selectedNote) {
                  setSelectedNote({ ...selectedNote, title: e.target.value });
                } else if (isCreating) {
                  // For new notes, we need to create a temporary note
                  const tempNote: Note = { 
                    ...newNoteTemplate, 
                    id: 'new', 
                    title: e.target.value,
                    created_at: new Date().toISOString(),
                    updated_at: new Date().toISOString(),
                    wordCount: 0,
                    characterCount: 0
                  };
                  setSelectedNote(tempNote);
                }
              }}
              className="w-full text-2xl font-semibold text-gray-900 placeholder-gray-500 border-none outline-none mb-6 bg-transparent"
            />

            {/* Content Editor */}
            <textarea
              ref={editorRef}
              value={currentNote.content}
              onChange={(e) => {
                if (selectedNote) {
                  setSelectedNote({ ...selectedNote, content: e.target.value });
                } else if (isCreating) {
                  // For new notes, update the temporary note
                  const tempNote: Note = { 
                    ...newNoteTemplate, 
                    id: 'new', 
                    content: e.target.value,
                    created_at: new Date().toISOString(),
                    updated_at: new Date().toISOString(),
                    wordCount: 0,
                    characterCount: 0
                  };
                  setSelectedNote(tempNote);
                }
              }}
              placeholder="Start writing..."
              className="w-full min-h-[400px] text-gray-900 leading-relaxed outline-none border-none resize-none bg-transparent"
              style={{ fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif' }}
            />
              
            {/* Tags */}
            <div className="mt-8 pt-6 border-t border-gray-200">
              <div className="flex items-center space-x-2">
                <Tag className="w-4 h-4 text-gray-400" />
                <span className="text-sm text-gray-500">Tags:</span>
                <div className="flex items-center space-x-2 flex-wrap">
                  {currentNote.tags.map((tag, index) => (
                    <span
                      key={index}
                      className="px-2 py-1 text-xs bg-blue-100 text-blue-700 rounded-full flex items-center space-x-1"
                    >
                      <span>#{tag}</span>
                      <button
                        onClick={() => removeTagFromNote(currentNote, tag)}
                        className="hover:text-blue-900"
                      >
                        <X className="w-3 h-3" />
                      </button>
                    </span>
                  ))}
                  <div className="relative">
                    <input
                      ref={tagsInputRef}
                      type="text"
                      placeholder="Add tag..."
                      value={tagsInput}
                      onChange={(e) => handleTagInputChange(e.target.value)}
                      onKeyDown={(e) => handleTagInputKeyDown(e, currentNote)}
                      onFocus={() => {
                        if (tagsInput.trim()) {
                          const suggestions = getTagSuggestions(tagsInput);
                          setTagSuggestions(suggestions);
                          setShowTagSuggestions(suggestions.length > 0);
                        }
                      }}
                      className="text-sm border-none outline-none placeholder-gray-400 bg-transparent text-gray-900 min-w-[100px]"
                    />
                    {showTagSuggestions && (
                      <div className="absolute top-full left-0 mt-1 bg-white border border-gray-200 rounded-lg shadow-lg z-20 max-h-32 overflow-y-auto">
                        {tagSuggestions.map((suggestion) => (
                          <button
                            key={suggestion}
                            onClick={() => selectTagSuggestion(suggestion, currentNote)}
                            className="w-full px-3 py-2 text-sm text-left hover:bg-gray-50 flex items-center space-x-2"
                          >
                            <Hash className="w-3 h-3 text-gray-400" />
                            <span>#{suggestion}</span>
                          </button>
                        ))}
                      </div>
                    )}
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </motion.div>
    );
  };

  const renderNotesGrid = () => {
    if (filteredNotes.length === 0 && selectedFolderId === 'all') {
      return (
        <div className="text-center py-16">
          <Type className="w-16 h-16 text-gray-300 mx-auto mb-4" />
          <h2 className="text-xl font-medium text-gray-600 mb-2">All Notes</h2>
          <p className="text-gray-500 mb-6">Create your first note to get started</p>
          <button
            onClick={handleCreateNote}
            className="px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors"
          >
            Create New Note
          </button>
        </div>
      );
    }

    return (
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4 p-6">
        {/* Create New Note Tile - show in all views */}
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          className={`border-2 border-dashed rounded-lg p-4 cursor-pointer hover:border-blue-400 hover:bg-blue-50 transition-all group note-tile ${
            selectedFolderId !== 'all' 
              ? `${getColorInfo(folders.find(f => f.id === selectedFolderId)?.color || 'blue').border} hover:${getColorInfo(folders.find(f => f.id === selectedFolderId)?.color || 'blue').bg}` 
              : 'border-gray-300'
          }`}
          onClick={() => selectedFolderId === 'all' ? handleCreateNote() : handleCreateNoteInFolder(selectedFolderId)}
        >
          <div className="note-tile-content">
            <div className="flex flex-col items-center justify-center h-full text-center">
              <Plus className="w-8 h-8 text-gray-400 group-hover:text-blue-500 mb-2" />
              <h3 className="text-sm font-medium text-gray-600 group-hover:text-blue-700">
                Create New Note
              </h3>
              <p className="text-xs text-gray-500 mt-1">
                {selectedFolderId === 'all' ? 'unassigned' : `in ${selectedFolderId}`}
              </p>
            </div>
          </div>
        </motion.div>

        {/* Existing Notes */}
        {filteredNotes.map((note) => {
          const noteColor = note.folderColor || note.color;
          const colorInfo = getColorInfo(noteColor);
          const categoryInfo = getCategoryInfo(note.folderId || '');
          
          return (
            <motion.div
              key={note.id}
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              className={`${colorInfo.bg} ${colorInfo.border} border rounded-lg p-4 cursor-pointer hover:shadow-md transition-all group relative note-tile`}
              onClick={() => {
                setSelectedNote(note);
                setIsEditing(true);
                setIsCreating(false);
              }}
            >
              <div className="note-tile-content">
                {/* Note Header */}
                <div className="note-tile-header flex items-start justify-between mb-3">
                  <div className="flex items-center space-x-2 min-w-0">
                    {note.isPinned && <Pin className="w-3 h-3 text-gray-400 flex-shrink-0" />}
                    {note.isStarred && <Star className="w-3 h-3 text-yellow-500 flex-shrink-0" />}
                    <span className={`${categoryInfo.bg} ${categoryInfo.color} text-xs px-2 py-1 rounded-full truncate`}>
                      {note.folderEmoji || categoryInfo.emoji} {note.folderName}
                    </span>
                  </div>

                  <div className="relative flex-shrink-0">
                    <button
                      onClick={(e) => {
                        e.stopPropagation();
                        setOpenMenuId(openMenuId === note.id ? null : note.id);
                      }}
                      className="opacity-0 group-hover:opacity-100 p-1 rounded hover:bg-gray-200 transition-all"
                    >
                      <MoreVertical className="w-4 h-4 text-gray-400" />
                    </button>
                    
                    {openMenuId === note.id && (
                      <div className="absolute right-0 top-6 bg-white border border-gray-200 rounded-lg shadow-lg z-10 py-1 w-40">
                        <button
                          onClick={(e) => {
                            e.stopPropagation();
                            togglePin(note.id);
                            setOpenMenuId(null);
                          }}
                          className="w-full flex items-center space-x-2 px-3 py-2 text-sm hover:bg-gray-50 text-left text-gray-700"
                        >
                          {note.isPinned ? <PinOff className="w-4 h-4" /> : <Pin className="w-4 h-4" />}
                          <span>{note.isPinned ? 'Unpin' : 'Pin'}</span>
                        </button>
                        <button
                          onClick={(e) => {
                            e.stopPropagation();
                            toggleStar(note.id);
                            setOpenMenuId(null);
                          }}
                          className="w-full flex items-center space-x-2 px-3 py-2 text-sm hover:bg-gray-50 text-left text-gray-700"
                        >
                          {note.isStarred ? <StarOff className="w-4 h-4" /> : <Star className="w-4 h-4" />}
                          <span>{note.isStarred ? 'Unstar' : 'Star'}</span>
                        </button>
                        <button
                          onClick={(e) => {
                            e.stopPropagation();
                            toggleArchive(note.id);
                            setOpenMenuId(null);
                          }}
                          className="w-full flex items-center space-x-2 px-3 py-2 text-sm hover:bg-gray-50 text-left text-gray-700"
                        >
                          <Archive className="w-4 h-4" />
                          <span>{note.isArchived ? 'Unarchive' : 'Archive'}</span>
                        </button>
                        <hr className="my-1" />
                        <button
                          onClick={(e) => {
                            e.stopPropagation();
                            handleDeleteNote(note.id);
                            setOpenMenuId(null);
                          }}
                          className="w-full flex items-center space-x-2 px-3 py-2 text-sm hover:bg-gray-50 text-left text-red-600"
                        >
                          <Trash2 className="w-4 h-4" />
                          <span>Delete</span>
                        </button>
                      </div>
                    )}
                  </div>
                </div>
                
                {/* Note Content Area - Flexible */}
                <div className="note-tile-body">
                  {/* Note Title */}
                  <h3 className={`${colorInfo.text} font-medium text-sm mb-2 line-clamp-2 leading-tight`}>
                    {note.title || 'Untitled Note'}
                  </h3>

                  {/* Note Content Preview */}
                  <p className="text-gray-600 text-sm line-clamp-2 leading-relaxed mb-3">
                    {note.content || 'No content'}
                  </p>

                  {/* Tags */}
                  {note.tags.length > 0 && (
                    <div className="flex flex-wrap gap-1 mb-3">
                      {note.tags.slice(0, 3).map((tag, index) => (
                        <span
                          key={index}
                          className="text-xs bg-white/50 text-gray-700 px-1.5 py-0.5 rounded-full flex items-center space-x-1"
                        >
                          <Hash className="w-2 h-2" />
                          <span>{tag}</span>
                        </span>
                      ))}
                      {note.tags.length > 3 && (
                        <span className="text-xs text-gray-500">+{note.tags.length - 3}</span>
                      )}
                    </div>
                  )}
                </div>

                {/* Note Footer - Fixed at bottom */}
                <div className="note-tile-footer flex items-center justify-between text-xs text-gray-500 pt-2 border-t border-gray-100">
                  <span className="truncate">{formatDate(note.updated_at)}</span>
                  <div className="flex items-center space-x-2 flex-shrink-0">
                    <span>{note.wordCount} words</span>
                    <Clock className="w-3 h-3" />
                    <span>{formatTime(note.updated_at)}</span>
                  </div>
                </div>
              </div>
            </motion.div>
          );
        })}
      </div>
    );
  };

  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (openMenuId && !(event.target as Element).closest('.menu-container')) {
        setOpenMenuId(null);
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, [openMenuId]);

  // Close menus when clicking outside
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      const target = event.target as Element;
      if (!target.closest('[data-menu]')) {
        setOpenMenuId(null);
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);

  // Add drag event handlers
  const handleDragStart = (e: React.DragEvent, folderId: string) => {
    setDraggedFolderId(folderId);
    e.dataTransfer.effectAllowed = 'move';
  };

  const handleDragOver = (e: React.DragEvent, folderId: string) => {
    e.preventDefault();
    if (draggedFolderId && draggedFolderId !== folderId) {
      setDragOverFolderId(folderId);
    }
  };

  const handleDragLeave = () => {
    setDragOverFolderId(null);
  };

  const handleDrop = async (e: React.DragEvent, targetFolderId: string) => {
    e.preventDefault();
    if (!draggedFolderId || draggedFolderId === targetFolderId) {
      setDraggedFolderId(null);
      setDragOverFolderId(null);
      return;
    }

    try {
      setIsReorderingFolders(true);
      setError(null);
      
      // Reorder folders in state
      const draggedFolder = folders.find(f => f.id === draggedFolderId);
      const targetFolder = folders.find(f => f.id === targetFolderId);
      
      if (!draggedFolder || !targetFolder) return;

      // Create new order
      const newFolders = [...folders];
      const draggedIndex = newFolders.findIndex(f => f.id === draggedFolderId);
      const targetIndex = newFolders.findIndex(f => f.id === targetFolderId);
      
      // Remove dragged folder and insert at target position
      const [draggedItem] = newFolders.splice(draggedIndex, 1);
      newFolders.splice(targetIndex, 0, draggedItem);
      
      // Update sort_order for all folders
      const updatedFolders = newFolders.map((folder, index) => ({
        ...folder,
        sort_order: index + 1
      }));
      
      setFolders(updatedFolders);
      
      // Persist new order to backend
      await updateFolderOrder(updatedFolders);
      
      setShowSuccess(true);
      setSuccessMessage('Folder order updated successfully!');
      setTimeout(() => setShowSuccess(false), 2000);
      
    } catch (error) {
      console.error('Error reordering folders:', error);
      setError('Failed to reorder folders. Please try again.');
      // Revert to original order on error
      fetchFolders();
    } finally {
      setIsReorderingFolders(false);
      setDraggedFolderId(null);
      setDragOverFolderId(null);
    }
  };

  const handleDragEnd = () => {
    setDraggedFolderId(null);
    setDragOverFolderId(null);
  };

  // Function to update folder order in backend
  const updateFolderOrder = async (updatedFolders: Folder[]) => {
    try {
      setIsReorderingFolders(true);
      const headers = await getAuthHeaders();
      
      const response = await fetch('/api/folders', {
        method: 'PUT',
        headers: {
          ...headers,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ folders: updatedFolders }),
      });

      if (!response.ok) {
        throw new Error('Failed to update folder order');
      }

      const data = await response.json();
      if (data.error) {
        throw new Error(data.error);
      }

      setFolders(updatedFolders);
    } catch (error) {
      console.error('Error updating folder order:', error);
      setError('Failed to update folder order. Please try again.');
    } finally {
      setIsReorderingFolders(false);
    }
  };

  // Bulk selection functions
  const toggleNoteSelection = (noteId: string) => {
    setSelectedNoteIds(prev => {
      const newSet = new Set(prev);
      if (newSet.has(noteId)) {
        newSet.delete(noteId);
      } else {
        newSet.add(noteId);
      }
      return newSet;
    });
  };

  const selectAllNotes = () => {
    setSelectedNoteIds(new Set(filteredNotes.map(note => note.id)));
  };

  const clearSelection = () => {
    setSelectedNoteIds(new Set());
  };

  const isAllSelected = selectedNoteIds.size === filteredNotes.length && filteredNotes.length > 0;
  const isPartiallySelected = selectedNoteIds.size > 0 && selectedNoteIds.size < filteredNotes.length;

  // Bulk action functions
  const performBulkAction = async (action: 'delete' | 'archive' | 'pin' | 'star', value?: boolean) => {
    if (selectedNoteIds.size === 0) return;

    const actionNames = {
      delete: 'delete',
      archive: value ? 'archive' : 'unarchive',
      pin: value ? 'pin' : 'unpin',
      star: value ? 'star' : 'unstar'
    };

    const message = action === 'delete' 
      ? `Are you sure you want to delete ${selectedNoteIds.size} note${selectedNoteIds.size > 1 ? 's' : ''}? This action cannot be undone.`
      : `Are you sure you want to ${actionNames[action]} ${selectedNoteIds.size} note${selectedNoteIds.size > 1 ? 's' : ''}?`;

    showConfirmation({
      title: `${action.charAt(0).toUpperCase() + action.slice(1)} Notes`,
      message,
      confirmText: action.charAt(0).toUpperCase() + action.slice(1),
      cancelText: 'Cancel',
      onConfirm: async () => {
        try {
          setIsPerformingBulkAction(true);
          setError(null);

          const headers = await getAuthHeaders();
          const updates: Partial<Note> = {};

          if (action === 'delete') {
            // Bulk delete
            const deletePromises = Array.from(selectedNoteIds).map(noteId =>
              fetch(`/api/notes/${noteId}`, {
                method: 'DELETE',
                headers,
              })
            );
            await Promise.all(deletePromises);
            
            // Remove from state
            setNotes(prev => prev.filter(note => !selectedNoteIds.has(note.id)));
            if (selectedNote && selectedNoteIds.has(selectedNote.id)) {
              setSelectedNote(null);
              setIsEditing(false);
              setIsCreating(false);
            }
          } else {
            // Bulk update
            if (action === 'archive') updates.isArchived = value;
            if (action === 'pin') updates.isPinned = value;
            if (action === 'star') updates.isStarred = value;

            const updatePromises = Array.from(selectedNoteIds).map(noteId =>
              fetch(`/api/notes/${noteId}`, {
                method: 'PUT',
                headers: {
                  ...headers,
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify(updates),
              })
            );
            await Promise.all(updatePromises);

            // Update state
            setNotes(prev => prev.map(note => 
              selectedNoteIds.has(note.id) ? { ...note, ...updates } : note
            ));
            
            // Update selected note if it's in the selection
            if (selectedNote && selectedNoteIds.has(selectedNote.id)) {
              setSelectedNote(prev => prev ? { ...prev, ...updates } : null);
            }
          }

          setSelectedNoteIds(new Set());
          setShowSuccess(true);
          setSuccessMessage(`Successfully ${actionNames[action]}ed ${selectedNoteIds.size} note${selectedNoteIds.size > 1 ? 's' : ''}!`);
          setTimeout(() => setShowSuccess(false), 2000);

        } catch (error) {
          console.error(`Error performing bulk ${action}:`, error);
          setError(`Failed to ${action} notes. Please try again.`);
        } finally {
          setIsPerformingBulkAction(false);
        }
      },
      isDestructive: action === 'delete',
    });
  };

  const moveNotesToFolder = async (folderId: string | undefined) => {
    if (selectedNoteIds.size === 0) return;

    const targetFolder = folderId ? folders.find(f => f.id === folderId) : null;
    const folderName = targetFolder?.name || 'unassigned';

    showConfirmation({
      title: 'Move Notes',
      message: `Move ${selectedNoteIds.size} note${selectedNoteIds.size > 1 ? 's' : ''} to "${folderName}"?`,
      confirmText: 'Move',
      cancelText: 'Cancel',
      onConfirm: async () => {
        try {
          setIsPerformingBulkAction(true);
          setError(null);

          const headers = await getAuthHeaders();
          const updates = {
            folderId: folderId || undefined,
            folderName: targetFolder?.name || undefined,
            folderColor: targetFolder?.color || undefined,
            folderEmoji: targetFolder?.emoji || undefined,
          };

          const updatePromises = Array.from(selectedNoteIds).map(noteId =>
            fetch(`/api/notes/${noteId}`, {
              method: 'PUT',
              headers: {
                ...headers,
                'Content-Type': 'application/json',
              },
              body: JSON.stringify(updates),
            })
          );
          await Promise.all(updatePromises);

          // Update state
          setNotes(prev => prev.map(note => 
            selectedNoteIds.has(note.id) ? { ...note, ...updates } : note
          ));
          
          // Update selected note if it's in the selection
          if (selectedNote && selectedNoteIds.has(selectedNote.id)) {
            setSelectedNote(prev => prev ? { ...prev, ...updates } : null);
          }

          setSelectedNoteIds(new Set());
          setShowSuccess(true);
          setSuccessMessage(`Successfully moved ${selectedNoteIds.size} note${selectedNoteIds.size > 1 ? 's' : ''} to "${folderName}"!`);
          setTimeout(() => setShowSuccess(false), 2000);

        } catch (error) {
          console.error('Error moving notes:', error);
          setError('Failed to move notes. Please try again.');
        } finally {
          setIsPerformingBulkAction(false);
        }
      },
    });
  };

  // Get all unique tags from notes
  const getAllTags = () => {
    const allTags = new Set<string>();
    notes.forEach(note => {
      note.tags.forEach(tag => allTags.add(tag));
    });
    return Array.from(allTags).sort();
  };

  // Get tag counts
  const getTagCounts = () => {
    const counts: Record<string, number> = {};
    notes.forEach(note => {
      note.tags.forEach(tag => {
        counts[tag] = (counts[tag] || 0) + 1;
      });
    });
    return counts;
  };

  // Filter notes by selected tags
  const filterNotesByTags = (notes: Note[]) => {
    if (selectedTags.size === 0) return notes;
    return notes.filter(note => 
      note.tags.some(tag => selectedTags.has(tag))
    );
  };

  // Tag management functions
  const toggleTagFilter = (tag: string) => {
    setSelectedTags(prev => {
      const newSet = new Set(prev);
      if (newSet.has(tag)) {
        newSet.delete(tag);
      } else {
        newSet.add(tag);
      }
      return newSet;
    });
  };

  const clearTagFilters = () => {
    setSelectedTags(new Set());
  };

  const addTagToNote = (note: Note, tag: string) => {
    if (!tag.trim() || note.tags.includes(tag.trim())) return;
    
    const newTags = [...note.tags, tag.trim()];
    if (selectedNote) {
      setSelectedNote({ ...selectedNote, tags: newTags });
    }
  };

  const removeTagFromNote = (note: Note, tagToRemove: string) => {
    const newTags = note.tags.filter(tag => tag !== tagToRemove);
    if (selectedNote) {
      setSelectedNote({ ...selectedNote, tags: newTags });
    }
  };

  const getTagSuggestions = (input: string) => {
    if (!input.trim()) return [];
    const allTags = getAllTags();
    return allTags.filter(tag => 
      tag.toLowerCase().includes(input.toLowerCase()) && 
      !input.toLowerCase().includes(tag.toLowerCase())
    );
  };

  // Update tag input handling
  const handleTagInputChange = (value: string) => {
    setTagsInput(value);
    const suggestions = getTagSuggestions(value);
    setTagSuggestions(suggestions);
    setShowTagSuggestions(suggestions.length > 0 && value.trim().length > 0);
  };

  const handleTagInputKeyDown = (e: React.KeyboardEvent, currentNote: Note) => {
    if (e.key === 'Enter' && tagsInput.trim()) {
      e.preventDefault();
      addTagToNote(currentNote, tagsInput.trim());
      setTagsInput('');
      setShowTagSuggestions(false);
    } else if (e.key === 'Escape') {
      setShowTagSuggestions(false);
    }
  };

  const selectTagSuggestion = (suggestion: string, currentNote: Note) => {
    addTagToNote(currentNote, suggestion);
    setTagsInput('');
    setShowTagSuggestions(false);
  };

  // Function to update note color
  const updateNoteColor = (color: string) => {
    if (selectedNote) {
      setSelectedNote({ ...selectedNote, color });
    }
    setShowNoteColorPicker(false);
  };

  // Get current note color info
  const getCurrentNoteColorInfo = () => {
    const currentNote = selectedNote || { ...newNoteTemplate, id: 'new', created_at: new Date().toISOString(), updated_at: new Date().toISOString(), wordCount: 0, characterCount: 0 };
    return noteColorOptions.find(c => c.name === currentNote.color) || noteColorOptions[0];
  };

  // Function to move note to folder
  const moveNoteToFolder = async (folderId: string | undefined) => {
    if (!selectedNote) return;

    const targetFolder = folderId ? folders.find(f => f.id === folderId) : null;
    const folderName = targetFolder?.name || 'unassigned';

    try {
      setError(null);
      
      const updates = {
        folderId: folderId || undefined,
        folderName: targetFolder?.name || undefined,
        folderColor: targetFolder?.color || undefined,
        folderEmoji: targetFolder?.emoji || undefined,
      };

      const updatedNote = await updateNote(selectedNote.id, updates);
      setSelectedNote(updatedNote);
      
      setShowFolderSelector(false);
      setShowSuccess(true);
      setSuccessMessage(`Note moved to "${folderName}" successfully!`);
      setTimeout(() => setShowSuccess(false), 2000);
    } catch (error) {
      console.error('Error moving note:', error);
      setError('Failed to move note. Please try again.');
    }
  };

  // Get current folder info
  const getCurrentFolderInfo = () => {
    if (!selectedNote?.folderId) return null;
    return folders.find(f => f.id === selectedNote.folderId);
  };

  // Confirmation dialog functions
  const showConfirmation = (config: {
    title: string;
    message: string;
    confirmText?: string;
    cancelText?: string;
    onConfirm: () => void;
    isDestructive?: boolean;
  }) => {
    setConfirmationDialog({
      isOpen: true,
      title: config.title,
      message: config.message,
      confirmText: config.confirmText || 'Confirm',
      cancelText: config.cancelText || 'Cancel',
      onConfirm: config.onConfirm,
      isDestructive: config.isDestructive || false,
    });
  };

  const hideConfirmation = () => {
    setConfirmationDialog(null);
  };

  const handleConfirm = () => {
    if (confirmationDialog) {
      confirmationDialog.onConfirm();
      hideConfirmation();
    }
  };

  if (isLoading) {
    return (
      <div className="min-h-screen bg-white flex items-center justify-center">
        <div className="text-center">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500 mx-auto mb-4"></div>
          <p className="text-gray-600">Loading your notes...</p>
        </div>
      </div>
    );
  }

  if (error) {
  return (
      <div className="min-h-screen bg-white flex items-center justify-center">
        <div className="text-center">
          <AlertCircle className="w-8 h-8 text-red-500 mx-auto mb-4" />
          <p className="text-red-600 mb-4">{error}</p>
              <button
            onClick={fetchNotes}
            className="px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors"
          >
            Try Again
              </button>
            </div>
            </div>
    );
  }

  return (
    <div className="min-h-screen bg-white">
      <TopBar isLoggedIn={true} />
      
      {/* Success Message */}
      <AnimatePresence>
        {showSuccess && (
          <motion.div
            initial={{ opacity: 0, y: -50 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -50 }}
            className="fixed top-20 left-1/2 transform -translate-x-1/2 z-50 bg-green-500 text-white px-4 py-2 rounded-lg shadow-lg"
          >
            <div className="flex items-center space-x-2">
              <CheckCircle className="w-4 h-4" />
              <span>{successMessage || 'Note saved successfully!'}</span>
              </div>
          </motion.div>
        )}
      </AnimatePresence>

      {/* Create Folder Modal */}
      <AnimatePresence>
        {showCreateFolder && (
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            className="fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center"
            onClick={() => setShowCreateFolder(false)}
          >
            <motion.div
              initial={{ scale: 0.95, opacity: 0 }}
              animate={{ scale: 1, opacity: 1 }}
              exit={{ scale: 0.95, opacity: 0 }}
              className="bg-white rounded-lg p-6 w-full max-w-md mx-4"
              onClick={(e) => e.stopPropagation()}
            >
              <div className="flex items-center space-x-2 mb-4">
                <FolderPlus className="w-5 h-5 text-blue-500" />
                <h3 className="text-lg font-semibold text-gray-900">Create New Folder</h3>
      </div>

              <input
                type="text"
                placeholder="Folder name..."
                value={newFolderName}
                onChange={(e) => setNewFolderName(e.target.value)}
                className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900 placeholder-gray-500"
                onKeyDown={(e) => {
                  if (e.key === 'Enter' && !isCreatingFolder) {
                    handleCreateFolder();
                  }
                }}
                disabled={isCreatingFolder}
              />
              
              <div className="flex items-center justify-end space-x-3 mt-6">
              <button
                  onClick={() => setShowCreateFolder(false)}
                  disabled={isCreatingFolder}
                  className="px-4 py-2 text-gray-600 hover:text-gray-800 transition-colors disabled:opacity-50"
                >
                  Cancel
              </button>
              <button
                  onClick={handleCreateFolder}
                  disabled={!newFolderName.trim() || isCreatingFolder}
                  className="px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors disabled:opacity-50 disabled:cursor-not-allowed flex items-center space-x-2"
                >
                  {isCreatingFolder && (
                    <div className="animate-spin rounded-full h-4 w-4 border-b border-white"></div>
                  )}
                  <span>{isCreatingFolder ? 'Creating...' : 'Create'}</span>
              </button>
            </div>
            </motion.div>
          </motion.div>
        )}
      </AnimatePresence>
      
      {/* Main Layout */}
      <div className="flex h-screen pt-16">
        {/* Sidebar */}
        {renderSidebar()}

        {/* Main Content */}
        <div className="flex-1 flex flex-col overflow-hidden">
          {selectedNote ? (
            renderNoteEditor()
          ) : (
            <div className="flex-1 overflow-y-auto">
              {/* Header */}
              <div className="border-b border-gray-200 p-4">
                <div className="flex items-center justify-between">
                  <div>
                    <h1 className="text-2xl font-semibold text-gray-900">
                      {selectedFolderId === 'all' ? 'All Notes' : folders.find(f => f.id === selectedFolderId)?.name || 'Unknown Folder'}
                    </h1>
                    <p className="text-gray-600">
                      {filteredNotes.length} {filteredNotes.length === 1 ? 'note' : 'notes'}
                      {selectedFolderId !== 'all' && ` in ${folders.find(f => f.id === selectedFolderId)?.name}`}
                    </p>
                  </div>
                  
                  <div className="flex items-center space-x-2">
                    <button
                      onClick={handleCreateNote}
                      className="px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors flex items-center space-x-2"
                    >
                      <Plus className="w-4 h-4" />
                      <span>New Note</span>
                    </button>
                  </div>
                </div>
              </div>

              {/* Notes Grid */}
              {renderNotesGrid()}
            </div>
          )}
        </div>
      </div>
      
      {/* Confirmation Dialog */}
      {confirmationDialog && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
          <div className="bg-white rounded-lg shadow-xl max-w-md w-full mx-4">
            <div className="p-6">
              <h3 className="text-lg font-semibold text-gray-900 mb-2">
                {confirmationDialog.title}
              </h3>
              <p className="text-gray-600 mb-6">
                {confirmationDialog.message}
              </p>
              <div className="flex space-x-3">
                <button
                  onClick={hideConfirmation}
                  className="flex-1 px-4 py-2 text-sm font-medium text-gray-700 bg-gray-100 rounded-lg hover:bg-gray-200 transition-colors"
                >
                  {confirmationDialog.cancelText}
                </button>
                <button
                  onClick={handleConfirm}
                  className={`flex-1 px-4 py-2 text-sm font-medium text-white rounded-lg transition-colors ${
                    confirmationDialog.isDestructive
                      ? 'bg-red-500 hover:bg-red-600'
                      : 'bg-blue-500 hover:bg-blue-600'
                  }`}
                >
                  {confirmationDialog.confirmText}
                </button>
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  );
} 